<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>delayedRender.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="ZS%252520TablePivot.html">ZS TablePivot</a></li><li><a href="ZS%252520TableSortable.html">ZS TableSortable</a></li></ul><h3>Events</h3><ul><li><a href="global.html#event:cellchangeFireswhenwecelldataischanged">cellchange Fires when we cell data is changed</a></li><li><a href="global.html#event:resizeFireswhenweresizetable">resize Fires when we resize table</a></li></ul><h3>Namespaces</h3><ul><li><a href="zs.table.html">table</a><ul class='methods'><li data-type='method'><a href="zs.table.html#.clearTable">clearTable</a></li><li data-type='method'><a href="zs.table.html#.considerPosition">considerPosition</a></li><li data-type='method'><a href="zs.table.html#.getTableData">getTableData</a></li><li data-type='method'><a href="zs.table.html#.refreshTable">refreshTable</a></li><li data-type='method'><a href="zs.table.html#.render">render</a></li><li data-type='method'><a href="zs.table.html#.renderCell">renderCell</a></li><li data-type='method'><a href="zs.table.html#.renderHead">renderHead</a></li><li data-type='method'><a href="zs.table.html#.renderHeadRow">renderHeadRow</a></li><li data-type='method'><a href="zs.table.html#.renderRow">renderRow</a></li><li data-type='method'><a href="zs.table.html#.renderTable">renderTable</a></li><li data-type='method'><a href="zs.table.html#.whenRendered">whenRendered</a></li></ul></li><li><a href="zs.tableDelayedRender.html">tableDelayedRender</a><ul class='methods'><li data-type='method'><a href="zs.tableDelayedRender.html#.renderTable">renderTable</a></li><li data-type='method'><a href="zs.tableDelayedRender.html#.renderTableSection">renderTableSection</a></li></ul></li><li><a href="zs.tableEditable.html">tableEditable</a><ul class='methods'><li data-type='method'><a href="zs.tableEditable.html#.cellClick">cellClick</a></li><li data-type='method'><a href="zs.tableEditable.html#.createField">createField</a></li><li data-type='method'><a href="zs.tableEditable.html#.fieldChange">fieldChange</a></li><li data-type='method'><a href="zs.tableEditable.html#.focusEditField">focusEditField</a></li><li data-type='method'><a href="zs.tableEditable.html#.formatCell">formatCell</a></li><li data-type='method'><a href="zs.tableEditable.html#.isEditable">isEditable</a></li><li data-type='method'><a href="zs.tableEditable.html#.nextField">nextField</a></li><li data-type='method'><a href="zs.tableEditable.html#.onWindowResize">onWindowResize</a></li><li data-type='method'><a href="zs.tableEditable.html#.positionOverlay">positionOverlay</a></li><li data-type='method'><a href="zs.tableEditable.html#.prevField">prevField</a></li><li data-type='method'><a href="zs.tableEditable.html#.renderCell">renderCell</a></li><li data-type='method'><a href="zs.tableEditable.html#.renderField">renderField</a></li><li data-type='method'><a href="zs.tableEditable.html#.renderOverlay">renderOverlay</a></li><li data-type='method'><a href="zs.tableEditable.html#.updateCellData">updateCellData</a></li></ul></li><li><a href="zs.tableFixedColumns.html">tableFixedColumns</a><ul class='methods'><li data-type='method'><a href="zs.tableFixedColumns.html#.decorateFixedHeaders">decorateFixedHeaders</a></li><li data-type='method'><a href="zs.tableFixedColumns.html#.matchScroll">matchScroll</a></li><li data-type='method'><a href="zs.tableFixedColumns.html#.renderHeadRow">renderHeadRow</a></li><li data-type='method'><a href="zs.tableFixedColumns.html#.renderHeadRow">renderHeadRow</a></li><li data-type='method'><a href="zs.tableFixedColumns.html#.renderRow">renderRow</a></li><li data-type='method'><a href="zs.tableFixedColumns.html#.renderRow">renderRow</a></li><li data-type='method'><a href="zs.tableFixedColumns.html#.renderTable">renderTable</a></li><li data-type='method'><a href="zs.tableFixedColumns.html#.renderTable">renderTable</a></li><li data-type='method'><a href="zs.tableFixedColumns.html#.resizeFixed">resizeFixed</a></li><li data-type='method'><a href="zs.tableFixedColumns.html#.whenRendered">whenRendered</a></li></ul></li><li><a href="zs.tableFixedColumnsDelayed.html">tableFixedColumnsDelayed</a><ul class='methods'><li data-type='method'><a href="zs.tableFixedColumnsDelayed.html#.renderTable">renderTable</a></li><li data-type='method'><a href="zs.tableFixedColumnsDelayed.html#.renderTableSection">renderTableSection</a></li></ul></li><li><a href="zs.html#.tableSmartRender">tableSmartRender</a><ul class='methods'><li data-type='method'><a href="zs.html#.tableSmartRender#.detectChanges">detectChanges</a></li><li data-type='method'><a href="zs.html#.tableSmartRender#.detectChanges">detectChanges</a></li><li data-type='method'><a href="zs.html#.tableSmartRender#.detectChangesUpdateHash">detectChangesUpdateHash</a></li><li data-type='method'><a href="zs.html#.tableSmartRender#.detectChangesUpdateHash">detectChangesUpdateHash</a></li><li data-type='method'><a href="zs.html#.tableSmartRender#.getHash">getHash</a></li><li data-type='method'><a href="zs.html#.tableSmartRender#.getRowHash">getRowHash</a></li><li data-type='method'><a href="zs.html#.tableSmartRender#.getRowKey">getRowKey</a></li><li data-type='method'><a href="zs.html#.tableSmartRender#.renderChanges">renderChanges</a></li></ul></li><li><a href="zs.tableStickyHeader.html">tableStickyHeader</a><ul class='methods'><li data-type='method'><a href="zs.tableStickyHeader.html#.clearTable">clearTable</a></li><li data-type='method'><a href="zs.tableStickyHeader.html#.decorateStickyCell">decorateStickyCell</a></li><li data-type='method'><a href="zs.tableStickyHeader.html#.resizeStickyHeader">resizeStickyHeader</a></li><li data-type='method'><a href="zs.tableStickyHeader.html#.scrollStickyHeader">scrollStickyHeader</a></li><li data-type='method'><a href="zs.tableStickyHeader.html#.stickHeader">stickHeader</a></li></ul></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">delayedRender.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>var zs = (function (zs) {
	'use strict';

	/**
	 * Delayed table render behavior. This is useful to improve the table rendering performance by rendering the table rows in smaller subsets.
	 * @namespace
	 */
	zs.tableDelayedRender = {

		/**
		 * Number of rows to be rendered at a given time.
		 * @type {number}
		 */
		renderStep: 10,

		/**
		 * Stores the array of animation request IDs.
		 * @type {Array}
		 */
		animRequests: [],

		/**
		 * Renders the subset of rows within the table.
		 * @param {Array} data Table data
		 * @param {number} start Start index from where we need to render the rows
		 * @param {number} end End index to render the rows
		 */
		renderTableSection: function(data, start, end) {
			console.log('tableDelayedRender', 'renderTableSection', start, end);
            for (var i = start; i &lt;= end; i++) {
                var tr = this.renderRow(i, data[i]);
                if (tr) { // We may render head row and return nothing
                    this.tbody.appendChild(tr);
                }
            }
		},

		/**
		 * Renders the table based on the provided data. Also, it creates all the required references and DOM elements if not already present.
		 */
		renderTable: function (data, mode) {
			console.log('tableDelayedRender', 'renderTable', data);
			var i,
				comp = this,
				body = '';

			var tableContainer = this.tableContainer || this;

			// Clear older animation requests in case of re-render.
			if (comp.animRequests &amp;&amp; comp.animRequests.length) {
				for (var i = 0; i &lt; comp.animRequests.length; i++) {
					window.cancelAnimationFrame(comp.animRequests[i]);
				}
				comp.animRequests = [];
			}

			// Empty table
			this.clearTable();

			// Create table
			if (!this.table) {
				this.table = this.querySelector('table') || document.createElement('table');
				this.table.classList.add('zs-data-table');
				this.table.style.tableLayout = 'fixed';
			}

			// Create thead and tbody
			if (!this.thead) {
				this.thead = this.table.querySelector('thead') || document.createElement('thead');
				this.table.appendChild(this.thead);
			}
			if (!this.tbody) {
				this.tbody = this.table.querySelector('tbody') || document.createElement('tbody');
				this.table.appendChild(this.tbody);
			}

			// Headers
			this.thead.appendChild(this.renderHeadRow());

			var step = this.renderStep;
			if (step>comp.data.length) {step = comp.data.length;}
			var requestId;
			i=0;
			function run() {	
				if (i&lt;data.length) {
					requestId = window.requestAnimationFrame(function() {
						if ((i + step) > data.length) {
							comp.renderTableSection(data, i, data.length - 1);
						} else {
							comp.renderTableSection(data, i, i + step - 1);
						}
						i+=step;
						run();
					});

					// Store animation requests, so that, we can clear them in case of re-render.
					comp.animRequests.push(requestId);
				} else {
					comp.dispatchEvent(new CustomEvent('render'));
				}
			}
			run();

			tableContainer.appendChild(this.table);

		}
	}

	
	
	/**
	 * Delayed fixed column table behavior. This is useful to improve the fixed column table rendering performance by rendering the table rows in smaller subsets.
	 * @namespace
	 */
	zs.tableFixedColumnsDelayed = {
		
		/**
		 * Number of rows to be rendered at a given time.
		 * @type {number}
		 */
		renderStep: 10,

		/**
		 * Stores the array of animation request IDs.
		 * @type {Array}
		 */
		animRequests: [],

		/**
		 * Renders the subset of rows within the table.
		 * @param {Array} data Table data
		 * @param {number} start Start index from where we need to render the rows
		 * @param {number} end End index to render the rows
		 * @param {HTMLElement} tbody Reference to the table body in normal (non-fixed) table.
		 * @param {HTMLElement} tbodyFixed Reference to the table body in fixed table.
		 */
		renderTableSection: function(data, start, end, tbody, tbodyFixed) {
			for (var i = start; i&lt;=end; i++) {
				var trFix = document.createElement('tr');				
				var tr = this.renderRow(i, data[i], trFix);				
				if (tr) { // We may render head row and return nothing
					tbody.appendChild(tr);
				}
				if (trFix) {
					tbodyFixed.appendChild(trFix);
				}
			}
		},

		/**
		 * Renders the table based on the provided data. Also, it creates all the required references and DOM elements if not already present.
		 */
		renderTable: function (data, mode) {
			console.log('render fixed delayed')
			var i, body = '', comp = this, tableContainer;

			// Clear older animation requests in case of re-render.
			if (comp.animRequests &amp;&amp; comp.animRequests.length) {
				for (var i = 0; i &lt; comp.animRequests.length; i++) {
					window.cancelAnimationFrame(comp.animRequests[i]);
				}
				comp.animRequests = [];
			}


			// Original render
			if (comp.loadingSet) {
				comp.loadingSet(true, comp); // hide spinner
			}
			if (!this.tableContainer) {
				this.tableContainer = document.createElement('div');
				this.appendChild(this.tableContainer);
			}
			tableContainer = this.tableContainer;

			comp.scrollEl = tableContainer; // !!!

			// Empty table
			this.clearTable();

			// Create table
			if (!this.table) {
				this.table = this.querySelector('table') || document.createElement('table');
				this.table.classList.add('zs-data-table');
				this.table.style.tableLayout = 'fixed';
			}

			// Create thead and tbody
			if (!this.thead) {
				this.thead = this.table.querySelector('thead') || document.createElement('thead');
				this.table.appendChild(this.thead);
			}
			if (!this.tbody) {
				this.tbody = this.table.querySelector('tbody') || document.createElement('tbody');
				this.table.appendChild(this.tbody);
			}

			// Define fixed container
			if (this.fixedColumnCount) {

				if (!this.fixedContainer) {
					this.fixedContainer = this.querySelector('.zs-fixed');
					if (!this.fixedContainer) {
						this.fixedContainer = document.createElement('div');
						this.appendChild(this.fixedContainer); // Important to append to overall container. Because we 
					}
				} else {
					this.fixedContainer.innerHTML = ''; // clear
				}


				// Create fixed table, head and body
				if (!this.fixedTable) {
					this.fixedTable = document.createElement('table');
					this.fixedTable.setAttribute('class', this.table.getAttribute('class'));
					this.fixedTable.style.tableLayout = 'fixed';

					this.fixedContainer.appendChild(this.fixedTable);
				} else {
					this.fixedTable.innerHTML = '';
				}


				this.fixedTableHead = document.createElement('thead');
				this.fixedTableBody = document.createElement('tbody');


				// Create a table container and move the table inside it
				this.fixedContainer.setAttribute('class', 'zs-fixed');
				this.fixedContainer.style.position = 'absolute';
				this.considerPosition('relative');

				this.fixedContainer.style.bottom = '0px';
				this.fixedContainer.style.left = '0px';
				this.fixedContainer.style.overflowY = 'hidden';
				this.fixedContainer.style.top = '0px';	// to make it inline with tablecontainer

				// Synchronize scroll 
				var waiting = false;
				comp.scrollEl.addEventListener('scroll', function (event) {
					if (!waiting) {
						waiting = true;

						window.requestAnimationFrame(function () {
							waiting = false;
							comp.matchScroll(comp.fixedContainer, comp.scrollEl);
						});
					}
				});

				// Disable iOS elastic scroll
				this.scrollFix(comp.scrollEl);


				// Listen to resize
				this.addEventListener('resize', function () {
					comp.resizeFixed(comp.fixedContainer, comp.scrollEl);
				});
			}



			// Headers			
			if (this.fixedColumnCount) {
				var trFix = document.createElement('tr');
				this.thead.appendChild(this.renderHeadRow(trFix));
				this.fixedTableHead.appendChild(trFix);
			} else {
				this.thead.appendChild(this.renderHeadRow());
			}

			var trFixed, tr;
			tableContainer.appendChild(this.table);
			
			if (this.fixedColumnCount) {
				this.fixedTable.appendChild(this.fixedTableHead);
				this.fixedTable.appendChild(this.fixedTableBody);
			}


			// Render sections
			var step = this.renderStep;
			if (step>comp.data.length) {step = comp.data.length;}
			var requestId;
			i=0;
			function run() {					
				if (i&lt;comp.data.length) {
					requestId = window.requestAnimationFrame(function() {
						
						if ((i + step) > comp.data.length) {
							comp.renderTableSection(comp.data, i, comp.data.length - 1, comp.tbody, comp.fixedTableBody);
						} else {
							comp.renderTableSection(comp.data, i, i+step-1, comp.tbody, comp.fixedTableBody);
						}

						if (comp.fixedColumnCount) {
							comp.resizeFixed(comp.fixedContainer, comp.scrollEl);
							comp.matchScroll(comp.fixedContainer, comp.scrollEl);
		
							// Adjust width and height of locked columns table and main table
							tableContainer.style.marginLeft = comp.fixedContainer.offsetWidth + 'px';
							comp.fixedContainer.firstElementChild.style.marginBottom = '100px';// compensate for scrollbar should 										
							comp.fixedContainer.style.height = tableContainer.offsetHeight + 'px';
		
						}		
						i+=step;
						run();			
					});

					// Store animation requests, so that, we can clear them in case of re-render.
					comp.animRequests.push(requestId);
				} else {
					comp.loadingSet(false, comp); // hide spinner
					comp.dispatchEvent(new CustomEvent('render'));
				}
			}
			run();		
		}
	}

	return zs;
})(window.zs || {});</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Tue Mar 05 2019 14:30:14 GMT+0530 (India Standard Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
